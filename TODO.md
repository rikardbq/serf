- [x] Add core functionality for write and read to db
- [x] fix the query function to allow more generic argument lists / partial application of query params
- [x] Handle different types of calls, I.E inserts vs fetches, etc (pass a subject in the token?)
- [x] Add web controllers in web lib
- [-] setup rest endpoints for actual use
    - [x] "{database}" more or less done
    - [] "{database}/migrate" (for running migrations)
        - scripts and management of these will have to be done on consumer side unless sqlx migrate has some feature for keeping track. Possibly both are needed to avoid calling the server when not needed.
- [-] start work on the CLI for adding users to user management db
    - [-] basic idea is to manage users with add, remove, modify commands (may have to use some library to manage sub-commanding)
    - same pattern would apply for managing DB's and user access to DB's (not final)
        - ```sqlite_server_cli add user -u rikardbq -p somepass```
        - ```sqlite_server_cli remove user -u rikardbq```
        - ```sqlite_server_cli modify user chpass -u rikardbq -op oldpass -np newpass```
- [] handle updates to the user management db so that the Arc handle gets the latest user hashmap
    - use "notify" crate to listen on the db file change?
- [x] root_dir=$HOME/.serf/ or %APPDATA_LOCAL%/.serf/ depending on architecture built on
    - consumer_db_path=$root_dir/db/{hashed_db_name}/
        - 1 folder per db to better namespace them on the filesystem since SQLite adds a bunch of meta files when manipulating the DB
- [x] use build.rs file with sane defaults
    - SERF_ROOT_DIR env in build script, defaults to ./serf from the project root dir when in dev
        - defaults(arch) in build scripts
            - [x] win: %APPDATA%\.serf
            - [] unix: $HOME/.serf
                - at build replace the values with either the sane defaults or provided args.
    - folders will be created and populated with necessary files
---

### BRANCH WORK/DECLUTTER
---
- [x] Create utility functions to handle CLI args in a simpler way
- [x] Create utility functions for retreiving database connections, check user access
- [x] Simplify flow in database access controller with utility for asserting user access for given claims subject and generating response claims
- [x] Add custom error type for clearer error messaging and differentiation in places where the return type to consumer may matter

### BRANCH CLI (merged)
---
- [x] Move user table creation to build.rs
- [x] Use env for setting the root dir defaults
- [x] Create Windows BATCH build and install script
- [x] Use transaction for initial users and access rights DB create
- [x] Further flesh out the CLI args list (needs more work)
- [x] Update AppState to include consumer DB root path(needs protection against escaping folder structure)
- [x] Update to execute_query fn to handle db transaction Executor type
- [x] Handle NULL data type in fetch as JsonValue as this also seems to be the type that is returned from column on json_group/object aggregators
- [x] Add queries const exports to cleanup the areas where DB calls are static and not dependent on user input
- [x] Use the users and access rights DB when checking user auth in database call from consumer
- [x] Change the database path param to be a hashed variant of the db name
- [x] Fetch users and access rights at srv bin startup and put in AppState usr field as Arc